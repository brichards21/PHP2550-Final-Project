---
title: "Methods and Analysis"
author: "Yanru Liao ,Jina Yang, Breanna Richards"
date: "2022-11-13"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message=FALSE, warning=FALSE, error=FALSE, echo = FALSE, fig.width = 5, fig.height = 3)

library(readr)
library(tidyverse)
library(randomForest)
library(regclass)
library(Boruta)
library(Amelia)
library(AUC)
library(ggplot2)
library(Metrics)
library(kableExtra)
library(knitr)
library(caret)
library(ROCR)
library(gt)
#library(rlang)
library(janitor)
library(mice)
library(dplyr)
```

Recall that the aim of this study is to assess if we can predict future isolate’s performance against certain antibiotics where ‘performance’ is a binary discretion of either susceptible or resistant. In other words, can we learn from past isolates to develop a system to recommend antibiotics to new isolates? We are also generally interested in the kinds of patterns that we can extract from our current data about behaviors of drug susceptibility and resistance including how responses to these antibiotics shift over time.

The analysis focuses on isolate data collected from the Salmonella enterica, E.coli and Shigella, and Campylobacter jejuni species in the National Center for Biotechnology Information’s (NCBI) Pathogen database. Initially, we had decided to evaluate isolates from these three bacteria within joint modelling and analysis procedures. However, through our data exploration process, we found that our Salmonella isolates had retained two additional pieces of information compared to the E.coli and Campylobacter isolates. This information are antigen formula, which  gives the detected presence of a specific viral antigen indicating viral infection, and serovar/serotype which gives the distinct variation within a certain bacteria. Additionally, while isolate data for Salmonella were retained from 2002 - 2021, E.coli and Campylobacter records didn’t begin presenting themselves in our data until much later (2009 for E.coli and Shigella, and 2016 for Campylobacter). For these reasons, we decided to address the Salmonella isolates separate from the E.coli and Campylobacter isolates, i.e., we’ll be building two separate models to address our main research question of interest: one for Salmonella isolates, and another for both E.coli and Campylobacter.

The full scope of our data contains isolates that are resistant and/or susceptible to 79 unique antibiotics, 76 of which these isolates have shown resistance to, and 62 of which these isolates have shown susceptibility to. Evidently, whereas some isolates have shown resistance to a certain durg, other isolates have shown susceptibility to the same drug. The idea is to create a system or function that will take information about isolates as input values and then within a subset of most common drugs we’ve found the isolates to show the most response to, reccomend the one that we’ve predicted with the most evidence that new isolate is most susceptible to, along with the level of confidence that we have in this recommendation (i.e. the probability that we obtain from our classification model). Therefore, since this is a binary classification problem, on the data that we’ll use to develop our models, we’ll code ‘1’ as drug susceptiblity, ‘0’ as drug resistance, and NA if we do not retain any information about that particular drug on a given particular isolate. 

As it’s not entirely feasible for us to predict drug response to each and every one of these 79 drugs, we decided to first focus on predicting responses to the most common drugs isolates represented in each of our now two separate datasets, one set for Salmonella, and a second joint set for Campylobacter and E.coli. Antibiotics up for consideration in our model fulfill one of two criteria: 1) represents at least 10% of all drugs within a given bacteria that were reported for isolate susceptibility or resistance, or 2) in the case that no drug represents at least 10% of all drugs reported for susceptibility or resistance within a given bacteria, be within the top two most common drugs that isolates of a given bacteria have shown susceptibility or resistance to. \textbf{Table 1} shows the most common antibiotics isolates within each bacteria showed resistance and susceptibility to. We combine the unique set of these antibiotics as the antibiotics that we will include in our model.


\begin{table}[hbtp]
\centering
\caption{Antibiotics Considered in Modeling}  
\includegraphics[width=10cm, height=10cm, keepaspectratio]{Appendix Tables/drug_tbl.png}
\end{table}

The final piece of pre-processing that our data has undergone involves the reformatting of the prevalence of the antimicrobrial resistant genes found in the isolates. There are 499 unique resistant genes found in the isolates within our data. In order to include some level of gene resistant presence as predictors in our model, we chose to include binary variables for the most common resistant genes observed in our data. These variables took a value of 1 if found within a given isolate, and a value of 0 is not found within a given isolate. The genes that we decided to include as predictors in each of the two separate models (one for Salmonella, and another jointly for E.coli and Campylobacter) are displayed in \textbf{Table 2}. We decided to retain the genes with over 2% prevalence in the Salmonella isolates, and the genes with over 3% prevalence in either the E.coli isolates or the Campylobacter isolates. A higher prevalence threshold of 3% was chosen for E.coli and Campylobacter as to not overpopulate the joint E.coli and Campylobacter model with these genetic predictors.  



\begin{table}[hbtp]
\centering
\caption{Antimicrobial Resistant Genes Considered in Modeling}  
\includegraphics[width=10cm, height=10cm, keepaspectratio]{Appendix Tables/anti_micr_tbl.png}
\end{table}

```{r}

# top susceptibility # top resistance # unique antibiotics used in model

# rownames - Salmonella enterica, E.coli and Shigella, Campylobacter jejuni

isolates_df <- read_csv("data/isolates_df.csv")

salmonella_df <- isolates_df %>%
  filter(organism_group == "Salmonella enterica")
# 8672 records

ecoli_df <- isolates_df %>%
  filter(organism_group == "E.coli and Shigella")

campy_df <- isolates_df %>%
  filter(organism_group == "Campylobacter jejuni")

ecoli_campy_df <- isolates_df %>%
  filter(organism_group != "Salmonella enterica")
# 7377  records 



```



```{r}

genes_salm <- unlist(str_split(salmonella_df$amr_genotypes, ","))

genes_ecoli <- unlist(str_split(ecoli_df$amr_genotypes, ","))

genes_campy <- unlist(str_split(campy_df$amr_genotypes, ","))


#length(unique(c(genes_salm, genes_ecoli, genes_campy)))

```


```{r}

common_genes_salm <- as.data.frame(sort(prop.table(table(genes_salm)), decreasing = T)) %>%
  filter(Freq >= 0.02)

common_genes_ecoli <- as.data.frame(sort(prop.table(table(genes_ecoli)), decreasing = T)) %>%
  filter(Freq >= 0.03)

common_genes_campy <- as.data.frame(sort(prop.table(table(genes_campy)), decreasing = T)) %>%
  filter(Freq >= 0.03)


```



```{r}


salmonella_df[paste0(common_genes_salm$genes_salm)] <- do.call(cbind, as.list(0))


anti_salm_df <- salmonella_df[, c(12, 26:37)]

for (i in 2:ncol(anti_salm_df)) {
  drug_test <- c(colnames(anti_salm_df[-c(4, 5, 6, 7)]),
                "tet\\(A\\)=COMPLETE",
                "aph\\(3''\\)-Ib=COMPLETE",
                "aph\\(6\\)-Id=COMPLETE",
                "tet\\(B\\)=COMPLETE")
    drug <- drug_test[i]
    
  for (j in 1:nrow(anti_salm_df)) {

  
  salmonella_df[j, drug] <- ifelse(grepl(drug, anti_salm_df[j, ]$amr_genotypes), 1, 0)
  
  }
  
}

salmonella_df <- salmonella_df[, -c(28:31)]

```


```{r}

genes_ecoli_campy <- unique(c(common_genes_ecoli$genes_ecoli,
         common_genes_campy$genes_campy))

ecoli_campy_df[paste0(genes_ecoli_campy)] <- do.call(cbind, as.list(0))


anti_ecoli_campy_df <- ecoli_campy_df[, c(12, 26:38)]

for (i in 2:ncol(anti_ecoli_campy_df)) {
  
    drug_test <- c(colnames(anti_ecoli_campy_df[-c(5, 6, 8, 9, 13)]),
                "tet\\(A\\)=COMPLETE",
                "aph\\(3''\\)-Ib=COMPLETE",
                "aph\\(6\\)-Id=COMPLETE",
                "tet\\(O\\)=COMPLETE",
                "aph\\(3'\\)-IIIa=COMPLETE")
    drug <- drug_test[i]
    
  for (j in 1:nrow(anti_ecoli_campy_df)) {

  
  ecoli_campy_df[j, drug] <- ifelse(grepl(drug, anti_ecoli_campy_df[j, ]$amr_genotypes), 1, 0)
  
  }
  
}

ecoli_campy_df <- ecoli_campy_df[, -c(29:30, 32:33, 37)]




```










\textbf{Justification for why this plan will answer your question}

The ultimate goal is to build a model or a series of models, rather, that will, out of the antibiotics that we chose to consider, recommend to new isolates the antibiotic predicted with the highest level of confidence that that new isolate will show susceptibility to. Approaching this task with the random forest classifier model is appropriate as we want to predict either a susceptible or resistant response for our isolates on each of the antibiotics and we can assess our levels of confidence as random forest implementation in R doesn't only return the predicted class of each observation, but also the probabilities associated with those predictions. Additionally, random forests is a type of non-parametric supervised machine learning model so we don't have to be held to stringent assumptions of our data like we would with parametric techniques like logistic regression. We are also interested generally in the kinds of patterns that we can extract from our current data, especially when it comes to the most pertinent covariates in the classification processes. We want to find which antimicrobial genes as well as which baseline covaraites are most helpful in deciding how to treat cases of foodborne illness in Salmonella, E.coli, and Campylobacter. And so, what is especially handy about random forests is its emphasis on feature selection. 

As feature selection is a built-in mechanism on random forests, the output of our models are able to provide a simple measure of how integral each variable of interest is to classification. This process will be paramount in extracting tangible insights about associations between drug susceptibility and resistance, and the supporting characteristic information logged in the NCBI database about each new case. Even pertaining to our goal of assessing how time plays a roll in predicting drug response, the mechanisms of the random forest algorithm in R makes it easy to assess the significance of time comparative to the other variables considered in modeling due to this variable importance feature.


The biggest limitation of implementing this model on our data is that it assumes our data are complete and non-missing. As the nature of the NCBI database is generally incomplete, this is a hurdle that we have to thoughtfully address. While we can impute these missing values in a pretty straight-forward process, when we have larger amounts of missingness, these imputed values become less and less reliable. 


\textbf{Initial implementation(s) - do a brief use case as a sanity check to make sure you understand how to use the methods and to catch any potential problems.}


We'll demonstrate the utilities of the `randomForest` function from the `randomForest` package in R on our data with a simple use case (Liaw and Wiener, 2002). For this example, we used our dataset for Salmonella enterica isolates and focused on the isoaltes' resistant/susceptible response to the antibiotic, tetracycline.

However, as aforementioned, before we ran this implemention, we first utilized the `Boruta` function from the `Boruta` package in order to perform variable selection (Kursa and Rudnicki, 2010). In action, the Boruta algorithm first adds randomness to the dataset of interest by creating shuffled copies of all of the features up for consideration. These new shuffled copies are called shadow features. Next, the function applies the random forest on the data and evaluates the importance of each of the features in the classification process. With each iteration of the classifier, the Boruta algorithm checks if the un-shuffled, original feature has a higher importance than the most important of its shuffled shadow features. If an original covariate is not deemed more important to classification than the best of that covariate's associated shadow features, then it is deemed unimportant and removed as a variable worth keeping in the modeling process. The Boruta algorithm stops when either all features are either confirmed or denied as being important, or alternatively when the maximum number of a specified number of random forest runs is reached. 



```{r}

tetra_test <- salmonella_df %>%
  mutate(tetracycline = ifelse(grepl("tetracycline", suscept_comb), 1,
ifelse(grepl("tetracycline", resist_comb), 0, NA))) %>%
  select(-c(strain, isolate, location, serovar,
            serotype, resist_comb, suscept_comb,
            resist, suscept, isolation_source,
            amr_genotypes, snp_cluster,
            antigen_formula)) %>%
  filter(!is.na(tetracycline)) %>%
  select(-organism_group)

cols <- c("isolation_type",
          "serovar_new", "country",
          "isolation_source_new",
          "antigen_formula_new",
         colnames(tetra_test)[12:24])



```


```{r}
# clean variable names
tetra_test <- tetra_test %>%
  clean_names()

```


A hurdle of utilizing this algorithm is that it only accepts non-missing data. As our current data currently obtains missing values, for the sake of this demonstration, as mentioned in data-preprocessing, we imputed missing values by utilizing the `mice` function from the `MICE` package in R.

To recap the algorithm, Multivariate Imputatoin via Chained Equations (MICE) assumes Missing at Random (MAR) data and imputes on a variable by variable basis, meaning that a new imputation model is specified with each new variable with missingness. Linear regression is used to predict missing values for continuous variables, and logistic regression is used to predict missing values for categorical variables.

```{r}

nom_cols <- c("isolation_type", "serovar_new", "country", "isolation_source_new",
              "antigen_formula_new", "mds_a_complete", "mds_b_complete",
              "sul2_complete", "sul1_complete", "bla_tem_1_complete",
"aad_a1_complete", "fos_a7_complete", "bla_cmy_2_complete",   
"tet_a_complete", "aph_3_ib_complete", "aph_6_id_complete",   
"tet_b_complete", "tetracycline")

#tetra_test <- tetra_test[, -11]
#tetra_test_use <- tetra_test[, c(1:7, 9:10)]

```


After ensuring that all of the categorical variables in our data are expressed as factors, we imputed our missing data.

```{r}

fact_cols <- c(cols[1:5], colnames(tetra_test)[12:ncol(tetra_test)])

tetra_test[fact_cols] <- lapply(tetra_test[fact_cols], factor)



```


Our use of this imputation algorithm will be more heavily scrutinized for the actual implementation of our methods on our data, but for now, we will impute values for any column without much criticism towards the values that are actually being imputed.

We will only work with 1 generated imputed dataset for the sake of this example.



```{r, echo=TRUE, eval=FALSE}

imputed_dat <- mice(data = tetra_test, m = 1,
     method = "pmm", maxit = 50, 
     seed = 500)
```




```{r, eval=FALSE}

complete_imputed <- complete(imputed_dat, 1)

```



```{r}



#write_csv(complete_imputed, #"data/imputed_tetra_test_df.csv")

imp_data <- read_csv("data/imputed_tetra_test_df.csv")


```



After imputing our data, we then move on to the `Boruta` feature selection process.



```{r, echo=TRUE, eval=FALSE}

boruta <- Boruta(tetracycline ~ ., 
data = imp_data, doTrace = 2, maxRuns = 500)

```


```{r}

#print(boruta)

```

From 12 iterations, the Boruta algorithm decided that none of the 23 predictors of consideration were unimportant, so we will will impute them all into the example classification algorithm.


We fit a model with drug susceptibility to the antibiotic, tetracycline, as our outcome of interest (a value of 1 for susceptible and a value of 0 for resistant), and the variables collection date, isolation type, minimum SNP distance to an isolate of the same isolation type, minimum SNP distance to an isolate of a different isolation type, serovar, country, isolation source, number of isolates "close" to that isolate (being close to another isolate being defined as having a minimum SNP distance less than or equal to 7 to an isolate of either the same or different isolation type),  antigen formula, average similarity scores between isolates within the same SNP cluster of antibiotics that isolates show resistance and susceptibility to, and finally a set of 12 binary variables indicating the genetic presence of 12 of the most common antimicrobial resistant genes in Salmonella.

Note that our outcome of interest, susceptibility on tetracycline is roughly balanced with 51.3% of the isolates showing resistance to tetracycline, and the remaining 48.8% showing susceptibility.


```{r}



imp_data[fact_cols] <- lapply(imp_data[fact_cols], factor)



```




```{r, echo = TRUE}

set.seed(1)

rand_forest_test <- randomForest(tetracycline ~.,
data = imp_data)

```


```{r}

# WITHOUT ANTIMICROBIAL RESIS GENES

# set.seed(1)
# 
# no_gene_tetra <- tetra_test[, c(1:11, 24)]
# 
# rand_forest_test2 <- randomForest(tetracycline ~.,
#                     data = no_gene_tetra,
#                      na.action = na.roughfix)

```



```{r}

#rand_forest_test$type
#rand_forest_test$ntree
#rand_forest_test$mtry

```

The output of the random forest command gives the type of random forest, which is classification in this case because our outcome is binary, the number of trees that were grown as a part of the process which in this case was the default 500 trees, and the number of variables tried at each split, which was 4, i.e. the value found by taking the largest integer value less than or equal to, otherwise known as the \textit{floor} value of the square root of the number of columns in the dataset (floor of the $\sqrt{24}$). 


The random forest function also provides a measure of the out of bag estimate of the error rate. While this is reported as 2.41% in the model output, we can also plot the out of bag error against the number of trees as well as plot this by class (resistant (0) vs. susceptible (1)).


```{r}

predicted_vals <- rand_forest_test$predicted


conf_matrix <- confusionMatrix(imp_data$tetracycline,
                               predicted_vals,
                               positive = '1')


roc_pred <- prediction(predictions = rand_forest_test$votes[, "1"] , 
            labels = imp_data$tetracycline)

perf <- performance(roc_pred, "tpr", "fpr")


auc_ROCR <- performance(roc_pred, measure = "auc")



```




```{r fig-tetra-obb, fig.cap= "Out of Bag Error Plot and ROC Curve for Tetracycline RF"}

par(mfrow = c(1, 2))
plot(rand_forest_test,
     main = "Out of Bag Error RF")
legend("topright", c("avg. OOB", "resist.", "suscept."),
       cex = 0.6,
       fill=1:ncol(rand_forest_test$err.rate))
plot(perf,
     main = "ROC Curve RF")
abline(a = 0, b = 1) 

```


```{r}

# WITHOUT GENES

# plot(rand_forest_test2,
  #   main = "Out of Bag Error RF")
# legend("topright", c("avg. OOB", "resist.", "suscept."),
  #     cex = 0.6,
  #     fill=1:ncol(rand_forest_test2$err.rate))



```

Notably, \textbf{Figure 1} shows that our model is stronger at predicting the tetracycline susceptibility class than the resistant class, a plot that can be supplemented with other performance related visuals like ROC curve.

We also can extract the statistics of interest based on the confusion matrix outputted from predicted classification. We just collected this on our full dataset for now just for demonstration purposes (\textbf{Table 3}). 

```{r}


acc <- as.numeric(conf_matrix$overall['Accuracy'])
sens <- as.numeric(conf_matrix$byClass['Sensitivity'])
spec <- as.numeric(conf_matrix$byClass['Specificity'])
pospred <- as.numeric(conf_matrix$byClass['Pos Pred Value'])
negpred <- as.numeric(conf_matrix$byClass['Neg Pred Value'])
auc_ROCR <- auc_ROCR@y.values[[1]]


```




```{r}

# 
# predicted_vals2 <- rand_forest_test2$predicted
# 
# 
# conf_matrix2 <- confusionMatrix(no_gene_tetra$tetracycline,
#                                predicted_vals,
#                                positive = '1')
# 
# 
# roc_pred2 <- prediction(predictions = rand_forest_test2$votes[, "1"] , 
#             labels = no_gene_tetra$tetracycline)
# 
# perf2 <- performance(roc_pred2, "tpr", "fpr")
# 
# 
# auc_ROCR2 <- performance(roc_pred2, measure = "auc")
# 
# 
# acc2 <- as.numeric(conf_matrix2$overall['Accuracy'])
# sens2 <- as.numeric(conf_matrix2$byClass['Sensitivity'])
# spec2 <- as.numeric(conf_matrix2$byClass['Specificity'])
# pospred2 <- as.numeric(conf_matrix2$byClass['Pos Pred Value'])
# negpred2 <- as.numeric(conf_matrix2$byClass['Neg Pred Value'])
# auc_ROCR2 <- auc_ROCR2@y.values[[1]]


```





```{r}

conf_df <- as.data.frame(conf_matrix$table) %>%
  pivot_wider(names_from = Prediction,
              values_from = Freq) 

```


```{r tabconf}

conf_gt <- gt(conf_df,
   caption = "Confusion Matrix for Drug Response on Tetracycline") %>% 
  tab_spanner(
    label = "Predicted",
    columns = c(`0`, `1`)
  )

```



```{r}

metric_tbl <- data.frame("Metric" = c("Accuracy", "Sensitivity", "Specificity",
                      "Pos Pred Value", "Neg Pred Value", 
                      "AUC"),
           "Value" = c(acc, sens, spec, pospred, negpred,
                       auc_ROCR))

```


```{r}

# WITHOUT GENES

# metric_tbl2 <- data.frame("Metric" = c("Accuracy", "Sensitivity", "Specificity",
#                       "Pos Pred Value", "Neg Pred Value", 
#                       "AUC"),
#            "Value" = c(acc2, sens2, spec2, pospred2, negpred2,
#                        auc_ROCR2))


```




```{r tab-perf-metr}

kable(metric_tbl, 
      caption = "Tetracycline RF Performance Metrics") %>%
  kable_styling()

```



```{r tab-perf-metr2}

# kable(metric_tbl2, 
#       caption = "Tetracycline RF Performance Metrics") %>%
#   kable_styling()

```

We will also use importance measures to extract information about the most important predictors in these cases of predicting drug response. Ultimately, we'll be comparing the results and important predictors of multiple models with susceptibility/resistance responses to each of the antibiotics of interest, in order to recommend antibiotics that we predict new isolates will show susceptibility to. In this simple case though, we show that we can extract the most important variables integral to the random forest classification of our data (Figure 2).

```{r}



var_imp_df5 <- cbind(varImp(rand_forest_test), var = rownames(varImp(rand_forest_test))) %>%
  arrange(desc(Overall)) %>%
  head(5)

```


```{r}

# var_imp_df10_2 <- cbind(varImp(rand_forest_test2), var = rownames(varImp(rand_forest_test2))) %>%
#   arrange(desc(Overall)) %>%
#   head(10)

```


```{r fig-imp, fig.cap= "Top 5 Most Important Covariates"}

ggplot(data = var_imp_df5,
       aes(x = fct_reorder(var, Overall), y = Overall)) + 
  geom_col(fill = "light blue", col = "white") +
  coord_flip() +
  labs(x = "", y = "Importance") +
  theme_bw()


```


```{r}

# ggplot(data = var_imp_df10_2,
#        aes(x = fct_reorder(var, Overall), y = Overall)) + 
#   geom_col(fill = "light blue", col = "white") +
#   coord_flip() +
#   labs(x = "", y = "Importance") +
#   theme_bw()


```


```{r}

#write_csv(salmonella_df, "data/salmonella_df.csv")
#write_csv(ecoli_campy_df, "data/ecoli_campy_df.csv")

```


Moving forward, we'll work to properly tune the hyperparameters within our random forest models and systematically expand this toy example to predict isolates' performances on larger sets of antibiotics which will hopefully retain usefulness in the assessment of future isolates to come.  


## References

A. Liaw and M. Wiener (2002). Classification and
  Regression by randomForest. R News 2(3), 18--22.
  
  
Miron B. Kursa, Witold R. Rudnicki (2010). Feature
  Selection with the Boruta Package. Journal of
  Statistical Software, 36(11), 1-13. URL
  http://www.jstatsoft.org/v36/i11/.